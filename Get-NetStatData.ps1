<#
.Synopsis
   This script will generate network connection data in a given set of servers for creation of dependency mapping graph.
.DESCRIPTION
   Generates the network connection data and copies to a central server at random time from each server between 12am and 1am.
.EXAMPLE
    .\Get-NetStatData.ps1 -UsePSRemoting

    Running the script with the switch 'UsePSRemoting' will execute the code for generating the data of network connections in each servers given in the text file with script file name Servers.txt using PowerShell Remoting.   
.EXAMPLE
    .\Get-NetStatData.ps1 -RegisterRemoteGetNetstatTask

    Running the script with the switch 'RegisterRemoteGetNetstatTask' will create scheduled tasks in client servers for generating netstat data in specified interval for specified duration as given in input file.   
.EXAMPLE
    .\Get-NetStatData.ps1 -UnregisterRemoteGetNetstatTask

    Running the script with the switch 'UnregisterRemoteGetNetstatTask' will remove scheduled tasks in client servers which are created for generating netstat data.
.EXAMPLE
    .\Get-NetStatData.ps1 -RegisterCopyOutputTask

    Running the script with the switch 'RegisterCopyOutputTask' will create a task for copying the output generated by the script in all servers in Servers.txt to central server. This will be scheduled randomly between 12am and 1am daily.      
.EXAMPLE
    .\Get-NetStatData.ps1 -UnregisterCopyOutputTask

    Running the script with the switch 'UnregisterCopyOutputTask' will delete the task created in all servers in Servers.txt.
.EXAMPLE
    .\Get-NetStatData.ps1 -UpdateCredentials

    Running the script with the switch 'UpdateCredentials' will help to encrypt and update the Input.config file with new credentials which is required for creating the tasks in client machines.   
.INPUTS
   There are two input files for this script, Input.config and Servers.txt. Input.config will contain the few input data and Servers.txt contains the list of servers on which the script has to run.
.OUTPUTS
   There will not be any output generated by the script in the Server from where it is executed other than a file name FailedServers.csv which will have the list of servers failed to connect with error message.
   In the the remote servers, netstat data will be generated as csv files and copied to central server periodically.
#>
[CmdletBinding()]
Param (
    [int]$ThrottleLimit = 50,
    [Switch]$UsePSRemoting,
    [Switch]$RegisterCopyOutputTask,
    [Switch]$UnregisterCopyOutputTask,
    [Switch]$RegisterRemoteGetNetstatTask,
    [Switch]$UnregisterRemoteGetNetstatTask,
    [Switch]$UpdateCredentials
)
[String]$TaskName = "CopyOutputTask"
$ScriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition

#This if block will help to encrypt and update the input file with new credentials which is required for creating the tasks in client machines.
if ($UpdateCredentials) {
    Write-Verbose "Encrypting and updating the credentials in the 'Input.config file'"
    $Cred = Get-Credential -Message "Enter the Service account"
    $Username = $Cred.UserName
    $Password = $Cred.GetNetworkCredential().Password
    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Password)
    $EncodedText = [Convert]::ToBase64String($Bytes)
    $InputFile = Get-Content $ScriptPath\Input.config
    $InputFile | foreach { $_ -replace '^Username.+$' , "UserName = $UserName" -replace '^Password.+$' , "Password = $EncodedText"} | Set-Content $ScriptPath\Input.config
}

function Import-Config {
<#
.Synopsis
    Importing config file.
.DESCRIPTION
    Importing config file and gives output as hash table.
.EXAMPLE
    Import-Config -path c:\temp\Import-Config.config
.EXAMPLE
    Import-Config -path D:\temp\Import-Config.config
.INPUTS
    Import-Config.config
.OUTPUTS
    Configuration table
.NOTES
    None
.FUNCTIONALITY
    Importing config file and gives output as hash table.
#>
    [CmdletBinding(DefaultParameterSetName='Parameter Set 1',
                    ConfirmImpact='Medium')]
    [OutputType([HashTable])]
    Param
    (
        [Parameter(Mandatory=$true, 
                    ValueFromPipeline=$true,
                    ValueFromPipelineByPropertyName=$true, 
                    ValueFromRemainingArguments=$false, 
                    Position=0)]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        $InputObject
    )

    Begin
    {
        $AppSettings = @{}
    }
    Process
    {
        foreach ($Line in $InputObject) 
        {
        $AddNode = $Line.Split("=",2)
        if(($AddNode[1]).Contains(‘,’)) 
            {
            $Value = ($AddNode[1]).Split(‘,’)
            for ($i = 0; $i -lt $Value.length; $i++) 
            { 
                $Value[$i] = $Value[$i].Trim() 
            }
            }
            else 
            {
            $Value = $AddNode[1].trim(" ")
            }
            $AppSettings[$AddNode[0].trim(" ")] = $Value
        }
    }
    End
    {
        $AppSettings
    }
}

#Importing the input data
Try {
    Write-Verbose "Importing the input data"
    $Data = Get-Content "$ScriptPath\Input.config" -ErrorAction Stop
    $Table = $Data | Import-Config -ErrorAction Stop
} 
Catch {
    Throw "Error occurred while importing the data from input file. Please check whether input file is present. Error Message : $_"
}

$UserName = $Table.UserName
$Password = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($Table.Password))
$Credential = New-Object System.Management.Automation.PSCredential ($Username,(ConvertTo-SecureString -AsPlainText -String $Password -Force))

#This if block will create a task for copying the output generated by the script in all servers in Servers.txt to central server. This will be scheduled randomly between 12am and 1am daily.
if ($RegisterCopyOutputTask) {
    Write-Verbose "Creating tasks in the remote servers for copying the netstat output to central server"
    $ScriptBlock = {
        Param (
            [Hashtable]$Table,
            [String]$TaskName
        )
        $Code = @"
if (Test-Path "$($Table.SharedPath)") {
    if (!(Test-Path "$($Table.SharedPath)\$($Table.SiteCode)\$env:USERDNSDOMAIN\$(Get-Date -f "dd-MM-yyyy")")) {
        mkdir "$($Table.SharedPath)\$($Table.SiteCode)\$env:USERDNSDOMAIN\$(Get-Date -f "dd-MM-yyyy")" -Force
    }
}
Copy-Item -Path "$($Table.Outputpath)\$($Table.SiteCode)-$Env:COMPUTERNAME.csv" -Destination "$($Table.SharedPath)\$($Table.SiteCode)\$env:USERDNSDOMAIN\$(Get-Date -f "dd-MM-yyyy")" -force
"@
        $Code | Out-File "$($Table.Outputpath)\Copy.ps1"

        $UserName = $Table.UserName
        $Password = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($Table.Password))
        $Minute = Get-Random -Maximum 60 -Minimum 10
        $TriggerTime = "12:$Minute"+"am"
        $ResumeActionscript = "-WindowStyle Normal -NoLogo -NoProfile -File `"$($Table.Outputpath)\Copy.ps1`""
        Get-ScheduledTask -TaskName $TaskName –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:$false
        $Act = New-ScheduledTaskAction -Execute "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -Argument $ResumeActionscript
        $Trigger = New-ScheduledTaskTrigger -Daily -At $TriggerTime
        Register-ScheduledTask $TaskName -Action $Act -Trigger $Trigger -User $UserName -Password $Password
    }
    Write-Verbose "Started remoting into the servers for executing the script"
    $Job = Invoke-Command -ComputerName (Get-Content "$ScriptPath\Servers.txt") -ScriptBlock $ScriptBlock -ArgumentList $Table, $TaskName -ThrottleLimit $ThrottleLimit -AsJob -ErrorAction Stop -Credential $Credential
}

#This if block will delete the task created in all servers in Servers.txt.
if ($UnregisterCopyOutputTask) {
    Write-Verbose "Removing tasks from the servers  for copying the netstat output to central server"  
    $ScriptBlock = {
        Param (
            [Hashtable]$Table,
            [String]$TaskName
        )
        Get-ScheduledTask -TaskName $TaskName –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:$false -ErrorAction SilentlyContinue
        Get-Item -Path "$($Table.Outputpath)\Copy.ps1" | Remove-Item -Force       
    }
    Write-Verbose "Started remoting into the servers for executing the script"
    $Job = Invoke-Command -ComputerName (Get-Content "$ScriptPath\Servers.txt") -ScriptBlock $ScriptBlock -ArgumentList $Table, $TaskName -ThrottleLimit $ThrottleLimit -AsJob -ErrorAction Stop -Credential $Credential
}

#This if block will create scheduled tasks in client servers for generating netstat data in specified interval for specified duration as given in input file.
if ($RegisterRemoteGetNetstatTask) {
    Write-Verbose "Creating tasks in the remote servers for generating netstat data"
    $InputFile = Get-Content $ScriptPath\Input.config
    $InputFile| foreach { $_ -replace '^Username.+$' , "" -replace '^Password.+$' , ""} | Set-Content $ScriptPath\LocalInput.config
    if (Test-Path "$($Table.SharedPath)") {
        if (!(Test-Path "$($Table.SharedPath)\Scripts")) {
            $Null = mkdir "$($Table.SharedPath)\Scripts" -Force
        }
        Copy-Item -Path "$ScriptPath\LocalInput.config" -Destination "$($Table.SharedPath)\Scripts\Input.config"
        Copy-Item -Path "$ScriptPath\RemoteScript.ps1" -Destination "$($Table.SharedPath)\Scripts"
    }
    Remove-Item -Path "$ScriptPath\LocalInput.config" -Force

    $ScriptBlock = {
        Param (
            [Hashtable]$Table
        )
        $TaskName = "GenerateNetstatData"
        if (!(Test-Path $Table.Outputpath)) {
            Try {
                $Null= mkdir $Table.Outputpath -Force -ErrorAction Stop
            }
            Catch {
                Throw "Can't create directory specified in the input file. Please check the path given is valid. Error message : $_"
            }
        }
        "Copying the script and input file"
        $Code = @"
Copy-Item -Path "$($Table.SharedPath)\Scripts\Input.config" -Destination "$($Table.Outputpath)"
Copy-Item -Path "$($Table.SharedPath)\Scripts\RemoteScript.ps1" -Destination "$($Table.Outputpath)"
Get-ScheduledTask -TaskName "GetScript" –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:`$false
Get-Item -Path "$($Table.Outputpath)\GetScript.ps1" | Remove-Item -Force
"@
        $Code | Out-File "$($Table.Outputpath)\GetScript.ps1"
        $UserName = $Table.UserName
        $Password = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($Table.Password))
        
        
        #Scheduling a Task to run once to copy script files from share folder in central server.
        $ResumeActionscript = "-WindowStyle Normal -NoLogo -NoProfile -File `"$($Table.Outputpath)\GetScript.ps1`""
        Get-ScheduledTask -TaskName "GetScript" –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:$false
        $Act = New-ScheduledTaskAction -Execute "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -Argument $ResumeActionscript
        $TriggerTime = ((Get-Date).AddMinutes(1))
        $Trigger = New-ScheduledTaskTrigger -Once -At $TriggerTime
        Register-ScheduledTask "GetScript" -Action $Act -Trigger $Trigger -User $UserName -Password $Password -ErrorAction Stop

        #Scheduling a Task for executing the script for getting netstat data.
        $ResumeActionscript = "-WindowStyle Normal -NoLogo -NoProfile -File `"$($Table.Outputpath)\RemoteScript.ps1`""
        Get-ScheduledTask -TaskName $TaskName –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:$false
        $Act = New-ScheduledTaskAction -Execute "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -Argument $ResumeActionscript
        $TriggerTime = Get-Date -f "HH:mm"
        $Trigger = New-ScheduledTaskTrigger -Once -At $TriggerTime -RepetitionDuration (New-TimeSpan -Days $($Table.Duration)) -RepetitionInterval (New-TimeSpan -Minutes $($Table.Interval))
        Register-ScheduledTask $TaskName  -Action $Act -Trigger $Trigger -User $UserName -Password $Password -ErrorAction Stop
    }
    Write-Verbose "Started remoting into the servers for executing the script"
    $Job = Invoke-Command -ComputerName (Get-Content "$ScriptPath\Servers.txt") -ScriptBlock $ScriptBlock -ArgumentList $Table -ThrottleLimit $ThrottleLimit -AsJob -ErrorAction Stop -Credential $Credential
}

#This if block will remove scheduled tasks in client servers which are created for generating netstat data.
if ($UnregisterRemoteGetNetstatTask) {
    Write-Verbose "Removing tasks in the remote servers for generating netstat data"
    $ScriptBlock = {
        Param (
            [Hashtable]$Table
        )
        $TaskName = "GenerateNetstatData"
        Get-ScheduledTask -TaskName $TaskName –EA SilentlyContinue | Unregister-ScheduledTask -Confirm:$false
        Get-Item -Path "$($Table.Outputpath)\RemoteScript.ps1" | Remove-Item -Force
        Get-Item -Path "$($Table.Outputpath)\Input.config" | Remove-Item -Force
    }
    Write-Verbose "Started remoting into the servers for executing the script"
    $Job = Invoke-Command -ComputerName (Get-Content "$ScriptPath\Servers.txt") -ScriptBlock $ScriptBlock -ArgumentList $Table -ThrottleLimit $ThrottleLimit -AsJob -ErrorAction Stop -Credential $Credential
}

#This if block will execute the code for generating the data of network connections in each servers gievn in the text file with script file name Servers.txt.
if ($UsePSRemoting) {
    Write-Verbose "Generating the network connection data in the servers using PSRemoting"
    $ScriptBlock = {
        Param (
            [Hashtable]$Table  
        )
     
        #region functions
        function Find-FreeDiskSpace {
        <#
        .Synopsis
           Finds the free space in a drive.
        .DESCRIPTION
           This will find the free space in a drive which is given as input. The output will be in percentage.
        .EXAMPLE
           Find-freeDiskSpace -DriveLetter
        .INPUTS
           Drive Letter
        .OUTPUTS
           Free disk space in percentage
        .NOTES
           None
        .FUNCTIONALITY
           Finds the free space in a drive.
        #>
            [CmdletBinding(DefaultParameterSetName='Parameter Set 1',
                           ConfirmImpact='Medium')]
            [OutputType([Int])]
            Param
            (
                # Param1 help description
                [Parameter(Mandatory=$true, 
                           ValueFromPipeline=$true,
                           ValueFromPipelineByPropertyName=$true, 
                           ValueFromRemainingArguments=$false, 
                           Position=0)]
                [ValidateNotNull()]
                [ValidateNotNullOrEmpty()]
                $DriveLetter
            )
   
            $DriveDetails = Get-WmiObject -Class win32_logicaldisk | Where-Object {$_.DeviceID -eq $DriveLetter}
            [math]::round($(($DriveDetails.FreeSpace)*100)/$($DriveDetails.Size))
        }

        function Get-NetStat {
        <#
        .Synopsis
           Gets Netstat data from local machine.
        .DESCRIPTION
           Fetches the current network connections of this computer. Runs the netstat -ano command and gives the output as objects
        .EXAMPLE
           Get-NetStat
        .INPUTS
           No input is required for this Cmdlet
        .OUTPUTS
           Output from this cmdlet is the current network connections of this computer.
        .NOTES
           General notes
        .FUNCTIONALITY
           Gets Netstat data from local machine.
        #>
            [CmdletBinding()]
            [OutputType([Object[]])]
            param()
            Begin {
                Write-Verbose "Fetching the network connection details"
            }    
            Process {
                Write-Verbose "Getting the output of netstat"
                $ExecutionTime = Get-Date -f "dd/MM/yyyy HH:mm:ss"
                Try {
                    $data = netstat -ano
                }
                Catch {
                    Throw "Error while executing netstat command"
                }
                $data = $data[4..$data.count]
                foreach ($line in $data)
                {
                    if ($line -match "UDP") {
                        $line = $line -replace '^\s+', ''
                        $line = $line -split '\s+'
            
                        Write-Verbose "Defining the properties"
                        $properties = @{
                            Protocol = $line[0]
                            LocalIP = ($line[1] -split ":")[0]
                            LocalPort = ($line[1] -split ":")[1]
                            RemoteIP = ($line[2] -split ":")[0]
                            RemotePort = ($line[2] -split ":")[1]
                            State = $null
                            PID = $line[3]
                            TimeStamp = $ExecutionTime
                        }
                    }
                    Else {
                        $line = $line -replace '^\s+', ''
                        $line = $line -split '\s+'
            
                        Write-Verbose "Defining the properties"
                        $properties = @{
                            Protocol = $line[0]
                            LocalIP = ($line[1] -split ":")[0]
                            LocalPort = ($line[1] -split ":")[1]
                            RemoteIP = ($line[2] -split ":")[0]
                            RemotePort = ($line[2] -split ":")[1]
                            State = $line[3]
                            PID = $line[4]
                            TimeStamp = $ExecutionTime
                        }
                    }
                        
                    Write-Verbose "Output the current line"
                    New-Object -TypeName PSObject -Property $properties |Select-Object TimeStamp, LocalIP, RemoteIP, LocalPort, RemotePort, Protocol, State, PID
                }
            }
            End {
                Write-Verbose "Completed fetching the network connection details"
            }
        }

        function Export-NetstatData {
        <#
        .Synopsis
           Exports Netstat data to a CSV File.
        .DESCRIPTION
           Takes the output from Get-NetStat and exports it as a CSV file after applying the filter given.
        .EXAMPLE
           Get-NetStat | Export-NetstatData -filter $Filter
        .INPUTS
           Output of Get-NetStat is the input for this Cmdlet
        .OUTPUTS
           There is no output for this cmdlet. Creates a CSV file.
        .NOTES
           General notes
        .FUNCTIONALITY
           Exports Netstat data to a CSV File.
        #>
            [CmdletBinding(DefaultParameterSetName='Parameter Set 1',
                           ConfirmImpact='Medium')]
            Param
            (
                #This should be output from Get-Netstat function
                [Parameter(Mandatory=$true, 
                           ValueFromPipeline=$true,
                           ValueFromPipelineByPropertyName=$true, 
                           ValueFromRemainingArguments=$false, 
                           Position=0)]
                [ValidateNotNull()]
                [ValidateNotNullOrEmpty()]
                $NetstatData,
                [Parameter(Mandatory=$true, 
                           Position=1)]
                [ValidateNotNull()]
                [ValidateNotNullOrEmpty()]
                $Filter,
                [Parameter(Mandatory=$true, 
                           Position=2)]
                [ValidateNotNull()]
                [ValidateNotNullOrEmpty()]
                $OutputPath,
                [Parameter(Mandatory=$true, 
                           Position=3)]
                [ValidateNotNull()]
                [ValidateNotNullOrEmpty()]
                $SiteCode
            )
            Begin {
                Write-Verbose "Initiating an empty array to store the NetstatData"
                $Netstat = @()
            }
        
            Process {
                #Executing the Get-Netstat function to fetch the data.
                Write-Verbose "Adding the output of Get-NetstatData to the array"    
                $Netstat += $NetstatData
            }

            End {
                $CurrentErrorActionPref = $ErrorActionPreference
                $ErrorActionPreference = "SilentlyContinue"

                #Filtering the output.
                Write-Verbose "Filtering the output" 
                $Output = $Netstat | Where-Object {$_.LocalIP -ne "0.0.0.0" -and $_.LocalIP -ne "127.0.0.1" -and $_.LocalIP -match [ipaddress]$_.LocalIP} |
                Where-Object $Filter |Select-Object -Property *, @{Label = "SiteCode"; e= {$SiteCode}}
    
                #Resloving hostnames for the remote ip addresses.
                Write-Verbose "Resloving hostnames for the remote ip addresses"
                foreach ($item in $Output) {
                    $RemoteHostName =  $Null
                    $RemoteHostName = [System.Net.Dns]::GetHostEntry($item.RemoteIP).HostName
                    if ($RemoteHostName) {
                        $item | Add-Member -NotePropertyName RemoteHostName -NotePropertyValue $RemoteHostName -ErrorAction Stop
                    }
                    else {
                        $item | Add-Member -NotePropertyName RemoteHostName -NotePropertyValue $Null -ErrorAction Stop
                    }
                }
                $ErrorActionPreference = "Stop"
    
                #Exporting the output to the CSV file.
                Write-Verbose "Exporting the output to the CSV file"
                Try {
                    if (Test-Path "$($OutputPath)\$($SiteCode)-$Env:COMPUTERNAME.csv") {
                        $Output | ConvertTo-Csv -NoTypeInformation | Select-Object -Skip 1 | Out-File -FilePath "$($OutputPath)\$($SiteCode)-$Env:COMPUTERNAME.csv" -Append -Encoding ascii
                    }
                    else {
                        $Output | Export-Csv "$($OutputPath)\$($SiteCode)-$Env:COMPUTERNAME.csv" -NoTypeInformation   
                    }
                }
                Catch {
                    Throw "Error during exporting output as CSV file. Error Message : $_"
                }
                Finally {
                    $ErrorActionPreference = $CurrentErrorActionPref
                }
            }
        }

        function Main {
        
            #Checking and output path and creating it if not exists
            Write-Verbose "Checking and output path and creating it if not exists"
            if (!(Test-Path $Table.Outputpath)) {
                Try {
                    $null= mkdir $Table.Outputpath -Force -ErrorAction Stop
                }
                Catch {
                    Throw "Can't create directory specified in the input file. Please check the path given is valid. Error message : $_"
                }
            }

            #Checking the diskspace avaliable in the drive where outputfile is generated.
            Write-Verbose "Checking the diskspace avaliable in the drive where outputfile is generated"
            $FreeSpace = Find-FreeDiskSpace -DriveLetter $(($Table.Outputpath).Split("\")[0])
            if ($FreeSpace -le 5) {
                Write-Output "Disk freespace is less than 5%. Aborting the script"
                break
            }

            #Building filter to remove the unwanted IP Addresses which is given in the input file.
            Write-Verbose "Building filter to remove the unwanted IP Addresses which is given in the input file"
            $IPsToExclude = $Table.IPsToExclude
            $Filter1  = Foreach ($item in $IPsToExclude) {
                "`$_.RemoteIP -ne `"$item`""
            }
            $Filter = [ScriptBlock]::Create( "$($Filter1 -join " -and ")")

            #Generating the Network connection data
            Write-Verbose "Generating the Network connection data"
            Get-NetStat | Export-NetstatData -Filter $Filter -OutputPath $Table.Outputpath -SiteCode $Table.SiteCode
        }
        #endregion

        Main
    }
    Write-Verbose "Started remoting into the servers for executing the script"
    $Job = Invoke-Command -ComputerName (Get-Content "$ScriptPath\Servers.txt") -ScriptBlock $ScriptBlock -ArgumentList $Table -ThrottleLimit $ThrottleLimit -AsJob -ErrorAction Stop -Credential $Credential
}

#Checking the job status
if ($Job) {
    Write-Verbose "Checking the job status"
    $ParentJobStatus = $Job | Wait-Job | Get-Job

    #Collecting all failed jobs and writing them to a csv file with error message
    if ($ParentJobStatus.State -eq "Failed") {
        Write-Verbose "Collecting all failed jobs and writing them to a csv file with error message"
        $FailedChildJobs = $ParentJobStatus.ChildJobs | Where-Object {$_.State -eq "Failed"}
        $FailedServers = @()
        $TimeStamp = Get-Date -f "dd/MM/yyyy HH:mm:ss"
        foreach ($item in $FailedChildJobs){
            $Server = $item.Location
            try {
                $item | Receive-Job -ErrorAction Stop
            }
            catch{
                $ErrorMessage = "$_"
            }
            $Hash = @{
                TimeStamp = $TimeStamp
                Server = $Server
                ErrorMessage = $ErrorMessage        
            }
            $FailedServers += New-Object -TypeName psobject -Property $Hash
        }
        $FailedServers | Export-Csv "$ScriptPath\FailedServers.csv" -NoTypeInformation -Append
    }
    Else {
        Write-Verbose "All the remote jobs are successfully completed"
    }
}
